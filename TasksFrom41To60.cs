using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;

namespace ProjectEuler
{
    public partial class Solutions
    {
        #region Problem 41 - Pandigital prime

        /*
We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once. For example, 2143 is a 4-digit pandigital and is also prime.

What is the largest n-digit pandigital prime that exists?
*/

        public static void Problem41()
        {
            var set = 123;
            for (var n = 4; n < 9; ++n)
            {
                set = set*10 + n;
                var perm = set.Permutations();
                var res = perm.Where(i => i.IsPrime());
                if (res.Any())
                    Console.WriteLine(res.Max());
            }

            /* for (var n = 987654321; n > 1; n-= 2)
                 if (n.IsPrime() && n.IsPandigital(9))
                 {
                     Console.WriteLine(n);
                     break;
                 }*/
        }

        #endregion

        #region Problem 42 - Coded triangle numbers

        /*
The nth term of the sequence of triangle numbers is given by, tn = ½n(n+1); so the first ten triangle numbers are:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

By converting each letter in a word to a number corresponding to its alphabetical position and adding these values we form a word value. For example, the word value for SKY is 19 + 11 + 25 = 55 = t10. If the word value is a triangle number then we shall call the word a triangle word.

Using words.txt (right click and 'Save Link/Target As...'), a 16K text file containing nearly two-thousand common English words, how many are triangle words?
*/

        public static void Problem42()
        {
            var hashset = new HashSet<int>();
            for (var n = 1; n < 1000; ++n)
                hashset.Add((n*(n + 1))/2);

            var line = File.ReadAllLines(@"Input\words.txt");
            var words = line[0].Split(',');
            var count = 0;
            foreach (var w in words)
            {
                var word = w.Trim();
                word = word.Substring(1, word.Length - 2);

                if (hashset.Contains(word.CharactersValue()))
                    count++;
            }

            Console.WriteLine(count);
        }

        #endregion

        #region Problem 43 - Sub-string divisibility

        /*
The number, 1406357289, is a 0 to 9 pandigital number because it is made up of each of the digits 0 to 9 in some order, but it also has a rather interesting sub-string divisibility property.

Let d1 be the 1st digit, d2 be the 2nd digit, and so on. In this way, we note the following:

d2d3d4=406 is divisible by 2
d3d4d5=063 is divisible by 3
d4d5d6=635 is divisible by 5
d5d6d7=357 is divisible by 7
d6d7d8=572 is divisible by 11
d7d8d9=728 is divisible by 13
d8d9d10=289 is divisible by 17
Find the sum of all 0 to 9 pandigital numbers with this property.
 */

        public static void Problem43()
        {
            long sum = 0;
            var defaultSet = new[] {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"};
            foreach (var d in new[] {"0", "2", "4", "6", "8"})
            {
                var currentSet = new List<string>(defaultSet);
                currentSet.Remove(d);

                var s = currentSet.Aggregate((a, b) => a + b);
                foreach (var p in s.Permutations())
                {
                    var perm = p.Substring(0, 3) + d + p.Substring(3, p.Length - 3);

                    if (perm[0] != '0')
                    {
                        if (Int32.Parse(perm.Substring(2, 3))%3 == 0)
                            if (perm[5] == '0' || perm[5] == '5')
                                if (Int32.Parse(perm.Substring(4, 3))%7 == 0)
                                    if (Int32.Parse(perm.Substring(5, 3))%11 == 0)
                                        if (Int32.Parse(perm.Substring(6, 3))%13 == 0)
                                            if (Int32.Parse(perm.Substring(7, 3))%17 == 0)
                                            {
                                                Console.WriteLine(perm);
                                                sum += long.Parse(perm);
                                            }
                    }
                }
            }

            Console.WriteLine("Sum=" + sum);
        }

        #endregion

        #region Problem 44 - Pendagon numbers

        /*
Pentagonal numbers are generated by the formula, Pn=n(3n-1)/2. The first ten pentagonal numbers are:

1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70  22 = 48, is not pentagonal.

Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = |Pk  Pj| is minimised; what is the value of D?
 */

        public static void Problem44()
        {
            var hashSet = new HashSet<int>();
            var list = new List<int>();
            for (var n = 1; n < 2500; ++n)
            {
                var temp = n*(3*n - 1)/2;
                hashSet.Add(temp);
                list.Add(temp);
            }

            for (var i = 0; i < list.Count; ++i)
                for (var j = i + 1; j < list.Count; ++j)
                {
                    if (hashSet.Contains(list[i] + list[j]) && hashSet.Contains(Math.Abs(list[i] - list[j])))
                    {
                        Console.WriteLine(Math.Abs(list[i] - list[j]));
                        return;
                    }
                }
        }

        #endregion

        #region Problem 45 - Triangular, pentagonal, and hexagonal

        /*
Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:

Triangle	 	Tn=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Pentagonal	 	Pn=n(3n1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	Hn=n(2n1)	 	1, 6, 15, 28, 45, ...
It can be verified that T285 = P165 = H143 = 40755.

Find the next triangle number that is also pentagonal and hexagonal.
 */

        public static void Problem45()
        {
            var triangle = new HashSet<long>();
            var pentagonal = new HashSet<long>();
            var hexagonal = new HashSet<long>();
            for (var n = 1; n < 1000000; ++n)
            {
                triangle.Add(n*(n + 1)/2);
                pentagonal.Add(n*(3*n - 1)/2);
                hexagonal.Add(n*(2*n - 1));
            }

            foreach (var t in triangle)
                if (t > 40755 && pentagonal.Contains(t) && hexagonal.Contains(t))
                {
                    Console.WriteLine(t);
                    return;
                }
        }

        #endregion

        #region Problem 46 - Goldbach's other conjecture

        /*
It was proposed by Christian Goldbach that every odd composite number can be written as the sum of a prime and twice a square.

9 = 7 + 2*1^2
15 = 7 + 2*2^2
21 = 3 + 2*3^2
25 = 7 + 2*3^2
27 = 19 + 2*2^2
33 = 31 + 2*1^2

It turns out that the conjecture was false.

What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?
*/

        public static void Problem46()
        {
            checked
            {

                var twiceSquare = new List<int>();
                for (var i = 1; i < 1000; ++i)
                    twiceSquare.Add((int) (2*Math.Pow(i, 2)));

                var primes = new HashSet<long>();
                for (var i = 1; primes.Count != 1000; ++i)
                    if (i.IsPrime())
                        primes.Add(i);

                for (var composite = 2; composite < 1000000; ++composite)
                {
                    if (composite%2 == 0 || primes.Contains(composite))
                        continue;

                    var found = twiceSquare.Any(ts => ts < composite && primes.Contains(composite - ts));

                    if (!found)
                    {
                        Console.WriteLine(composite);
                        break;
                    }
                }
            }
        }

        #endregion

        #region Problem 47 - Distinct primes factors

        /*

The first two consecutive numbers to have two distinct prime factors are:

14 = 2 x 7
15 = 3 x 5

The first three consecutive numbers to have three distinct prime factors are:

644 = 2² x 7 x 23
645 = 3 x 5 x 43
646 = 2 x 17 x 19.

Find the first four consecutive integers to have four distinct prime factors. What is the first of these numbers?
*/

        public static void Problem47()
        {
            var counter = 0;
            for (var i = 2; i < Int32.MaxValue; ++i)
            {
                if (i.Factorization().Distinct().Count() == 4)
                {
                    counter++;

                    if (counter == 4)
                    {
                        Console.WriteLine(i - 3);
                        Console.WriteLine(i - 2);
                        Console.WriteLine(i - 1);
                        Console.WriteLine(i);
                        return;
                    }
                }
                else
                {
                    counter = 0;
                }
            }
        }

        #endregion

        #region Problem 48 - Self powers

        /*
The series, 1^1 + 2^2 + 3^3 + ... + 10^10 = 10405071317.

Find the last ten digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000.
 */

        public static void Problem48()
        {
            BigInteger sum = 0;
            for (var i = 1; i <= 1000; ++i)
            {
                sum += BigInteger.Pow(i, i);
            }

            var s = sum.ToString();
            Console.WriteLine(s.Substring(s.Length - 10, 10));
        }

        #endregion

        #region Problem 49- Prime permutations

        /*
The arithmetic sequence, 1487, 4817, 8147, in which each of the terms increases by 3330, is unusual in two ways: (i) each of the three terms are prime, and, (ii) each of the 4-digit numbers are permutations of one another.

There are no arithmetic sequences made up of three 1-, 2-, or 3-digit primes, exhibiting this property, but there is one other 4-digit increasing sequence.

What 12-digit number do you form by concatenating the three terms in this sequence?
 */

        public static void Problem49()
        {
            for (var i = 2; i < 6669; ++i)
            {
                if (i.IsPrime())
                {
                    var i2 = i + 3330;
                    var i3 = i2 + 3330;
                    if (i.IsPermutation(i2) && i.IsPermutation(i3) && i2.IsPrime() && i3.IsPrime())
                    {
                        Console.WriteLine(i.ToString(CultureInfo.InvariantCulture) +
                                          i2.ToString(CultureInfo.InvariantCulture) +
                                          i3.ToString(CultureInfo.InvariantCulture));
                        Console.WriteLine();
                    }
                }
            }
        }

        #endregion

        #region Problem 50 - Consecutive prime sum

        /*
The prime 41, can be written as the sum of six consecutive primes:

41 = 2 + 3 + 5 + 7 + 11 + 13
This is the longest sum of consecutive primes that adds to a prime below one-hundred.

The longest sum of consecutive primes below one-thousand that adds to a prime, contains 21 terms, and is equal to 953.

Which prime, below one-million, can be written as the sum of the most consecutive primes?
*/

        public static void Problem50()
        {
            var max = 1000000;
            var primes = 9999.GetPrimes().ToList();

            int maxPossibleLength;
            var sum = 0;
            for (maxPossibleLength = 0; maxPossibleLength < primes.Count(); ++maxPossibleLength)
                if ((sum += primes[maxPossibleLength]) > max)
                    break;


            for (var currentLength = maxPossibleLength; currentLength >= 1; --currentLength)
            {
                for (var offset = 0; offset < currentLength; ++offset)
                {
                    var n = primes.Skip(offset).Take(currentLength).Sum();
                    if (n < max && n.IsPrime())
                    {
                        Console.WriteLine(n);
                        return;
                    }
                }
            }
        }

        #endregion

        #region Problem 51 - Prime digit replacements

        /*
By replacing the 1st digit of the 2-digit number *3, it turns out that six of the nine possible values: 
13, 23, 43, 53, 73, and 83, are all prime.

By replacing the 3rd and 4th digits of 56**3 with the same digit, this 5-digit number is the first example 
having seven primes among the ten generated numbers, yielding the family: 56003, 56113, 56333, 56443, 56663, 56773, and 56993. Consequently 56003, being the first member of this family, is the smallest prime with this property.

Find the smallest prime which, by replacing part of the number (not necessarily adjacent digits) with the 
same digit, is part of an eight prime value family.
*/

        public static void Problem51()
        {
            var primes = 999999.GetPrimes().Where(p => p > 100);
            foreach (var p in primes)
            {
                var primeAsString = p.ToString(CultureInfo.InvariantCulture);

                for (var i = 0; i < primeAsString.Length - 1; ++i)
                    for (var j = i + 1; j < primeAsString.Length - 2; ++j)
                        for (var k = j + 1; k < primeAsString.Length; ++k)
                        {
                            var list = new List<string>();
                            var length = 0;
                            for (var replacement = i == 0 ? 1 : 0; replacement <= 9; ++replacement)
                            {
                                var newNumber =
                                    primeAsString.Substring(0, i) +
                                    replacement +
                                    primeAsString.Substring(i + 1, j - i - 1) +
                                    replacement +
                                    primeAsString.Substring(j + 1, k - j - 1) +
                                    replacement +
                                    primeAsString.Substring(k + 1, primeAsString.Length - k - 1);

                                if (Int32.Parse(newNumber).IsPrime())
                                {
                                    list.Add(newNumber);
                                    length++;
                                }

                                if (length == 8 && list.Contains(primeAsString))
                                {
                                    Console.WriteLine(p);
                                    return;
                                }
                            }
                        }
            }
        }

        #endregion

        #region Problem 52 - Permuted multiples

        /*
It can be seen that the number, 125874, and its double, 251748, contain exactly the same digits, but in a different order.

Find the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and 6x, contain the same digits.
*/

        public static int Problem52()
        {
            for (var i = 1; i < Int32.MaxValue; ++i)
            {
                if ((2*i).IsPermutation(i) &&
                    (3*i).IsPermutation(i) &&
                    (4*i).IsPermutation(i) &&
                    (5*i).IsPermutation(i) &&
                    (6*i).IsPermutation(i))
                {
                    return i;
                }
            }

            return -1;
        }

        #endregion

        #region Problem 53 - Combinatoric selections

        public static int Problem53()
        {
            var count = 0;
            for (var n = 1; n <= 100; n++)
            {
                var i = 0;
                for (var k = 1; k <= n; k++)
                {
                    if (NewtonSymbol(n, k) > 1000000)
                    {
                        i++;
                        count++;
                    }
                }

                if (i == n)
                    Console.WriteLine(n);
            }

            return count;
        }

        public static BigInteger NewtonSymbol(BigInteger n, BigInteger k)
        {
            checked
            {

                BigInteger res = 1;

                for (var i = 1; i <= k; ++i)
                    res = res*(n - i + 1)/i;

                return res;
            }
        }

        #endregion

        #region Problem 54 - Poker

        public class Result
        {
            public int Value { get; set; }
            public int? Highest1 { get; set; }
            public int? Highest2 { get; set; }
        }

        public static int Problem54()
        {
            var count = 0;
            foreach (var s in File.ReadAllLines(@"Input\poker.txt"))
            {
                var cards = s.Split(' ');
                var first = new List<Tuple<int, char>>();
                var second = new List<Tuple<int, char>>();

                for (var i = 0; i < 5; ++i)
                    first.Add(new Tuple<int, char>(CardValue(cards[i][0]), cards[i][1]));

                first = first.OrderByDescending(t => t.Item1).ToList();

                for (var i = 5; i < 10; ++i)
                    second.Add(new Tuple<int, char>(CardValue(cards[i][0]), cards[i][1]));

                second = second.OrderByDescending(t => t.Item1).ToList();

                var firstRes = CardsResult(first);
                var secondRes = CardsResult(second);

                if (IsGreater(first, second, firstRes, secondRes))
                    count++;
            }

            return count;
        }

        private static bool IsGreater(List<Tuple<int, char>> first, List<Tuple<int, char>> second, Result firstRes,
                                      Result secondRes)
        {
            if (firstRes.Value > secondRes.Value)
                return true;

            if (firstRes.Value < secondRes.Value)
                return false;

            if (firstRes.Highest1 != null && secondRes.Highest1 != null)
            {
                if (firstRes.Highest1 > secondRes.Highest1)
                    return true;

                if (firstRes.Highest1 < secondRes.Highest1)
                    return false;
            }

            if (firstRes.Highest2 != null && secondRes.Highest2 != null)
            {
                if (firstRes.Highest2 > secondRes.Highest2)
                    return true;

                if (firstRes.Highest2 < secondRes.Highest2)
                    return false;
            }

            if (IsGreater(first, second))
                return true;

            return false;
        }

        private static bool IsGreater(List<Tuple<int, char>> first, List<Tuple<int, char>> second)
        {
            for (var i = 0; i < first.Count; ++i)
                if (first[i].Item1 > second[i].Item1)
                    return true;
                else if (first[i].Item1 < second[i].Item1)
                    return false;

            return false;
        }

        private static Result CardsResult(List<Tuple<int, char>> cards)
        {
            if (IsRoyalFlush(cards))
                return new Result { Value = 10 };

            if (IsStraightFlush(cards))
                return new Result { Value = 9 };

            var four = FourOfKind(cards);
            if (four != null)
                return new Result { Value = 8, Highest1 = four.Value };

            var full = FullHouse(cards);
            if (full != null)
                return new Result { Value = 7, Highest1 = full[0], Highest2 = full[1] };

            if (IsFlush(cards))
                return new Result { Value = 6 };

            if (IsStraight(cards))
                return new Result { Value = 5 };

            var three = ThreeOfKind(cards);
            if (three != null)
                return new Result { Value = 4, Highest1 = three.Value };

            var pairs = TwoPairs(cards);
            if (pairs != null)
                return new Result { Value = 3, Highest1 = pairs[0], Highest2 = pairs[1] };

            var pair = OnePair(cards);
            if (pair != null)
                return new Result { Value = 2, Highest1 = pair.Value };

            return new Result { Value = 1 };
        }

        private static int? OnePair(IEnumerable<Tuple<int, char>> cards)
        {
            var res =
                cards.GroupBy(ch => ch.Item1)
                     .Select(g => new {Card = g.Key, Count = g.Count()})
                     .FirstOrDefault(g => g.Count == 2);

            return res != null ? res.Card : (int?) null;
        }

        private static int[] TwoPairs(IEnumerable<Tuple<int, char>> cards)
        {
            var res =
                cards.GroupBy(ch => ch.Item1)
                     .Select(g => new { Card = g.Key, Count = g.Count() })
                     .Where(g => g.Count == 2)
                     .OrderByDescending(g => g.Card).ToList();

            if (res.Count == 2)
                return new[] { res[0].Card, res[1].Card };

            return null;
        }

        private static int? ThreeOfKind(IEnumerable<Tuple<int, char>> cards)
        {
            var res =
                cards.GroupBy(ch => ch.Item1)
                     .Select(g => new {Card = g.Key, Count = g.Count()})
                     .FirstOrDefault(g => g.Count == 3);

            return res != null ? res.Card : (int?) null;
        }

        private static bool IsStraight(IList<Tuple<int, char>> cards)
        {
            return
                cards[0].Item1 - cards[1].Item1 == 1 &&
                cards[1].Item1 - cards[2].Item1 == 1 &&
                cards[2].Item1 - cards[3].Item1 == 1 &&
                cards[3].Item1 - cards[4].Item1 == 1;
        }

        private static bool IsFlush(IList<Tuple<int, char>> cards)
        {
            return OfTheSameSuit(cards);
        }

        private static int[] FullHouse(IEnumerable<Tuple<int, char>> cards)
        {
            var three = ThreeOfKind(cards);
            var pair = OnePair(cards);

            if (three != null && pair != null)
                return new[] { three.Value, pair.Value };

            return null;
        }

        private static int? FourOfKind(IEnumerable<Tuple<int, char>> cards)
        {
            var res =
                cards.GroupBy(ch => ch.Item1)
                     .Select(g => new {Card = g.Key, Count = g.Count()})
                     .FirstOrDefault(g => g.Count == 4);

            return res != null ? res.Card : (int?) null;
        }

        private static bool IsStraightFlush(IList<Tuple<int, char>> cards)
        {
            return OfTheSameSuit(cards) && IsStraight(cards);
        }

        private static bool IsRoyalFlush(IList<Tuple<int, char>> cards)
        {
            return OfTheSameSuit(cards) && cards.Sum(c => c.Item1) == 10 + 11 + 12 + 13 + 14;
        }

        private static bool OfTheSameSuit(IList<Tuple<int, char>> cards)
        {
            return cards.All(c => c.Item2 == cards[0].Item2);
        }

        private static int CardValue(char ch)
        {
            if (ch == 'T')
                return 10;

            if (ch == 'J')
                return 11;

            if (ch == 'Q')
                return 12;

            if (ch == 'K')
                return 13;

            if (ch == 'A')
                return 14;

            return Int32.Parse(ch.ToString(CultureInfo.InvariantCulture));
        }

        #endregion

        #region Problem 55 - Lychrel numbers

        /*
If we take 47, reverse and add, 47 + 74 = 121, which is palindromic.

Not all numbers produce palindromes so quickly. For example,

349 + 943 = 1292,
1292 + 2921 = 4213
4213 + 3124 = 7337

That is, 349 took three iterations to arrive at a palindrome.

Although no one has proved it yet, it is thought that some numbers, like 196, never produce a palindrome. 
 * A number that never forms a palindrome through the reverse and add process is called a Lychrel number. 
 * Due to the theoretical nature of these numbers, and for the purpose of this problem, we shall assume 
 * that a number is Lychrel until proven otherwise. In addition you are given that for every number below 
 * ten-thousand, it will either (i) become a palindrome in less than fifty iterations, or, (ii) no one, 
 * with all the computing power that exists, has managed so far to map it to a palindrome. In fact, 10677 is 
 * the first number to be shown to require over fifty iterations before producing a palindrome: 
 * 4668731596684224866951378664 (53 iterations, 28-digits). 
*/

        public static int Problem55()
        {
            var count = 0;
            for (var i = 1; i < 10000; ++i)
            {
                BigInteger temp = i;
                for (var j = 0; j < 50; ++j)
                {
                    temp = temp + BigInteger.Parse(String.Join(String.Empty, temp.ToString().Reverse().ToArray()));

                    if (temp.ToString(CultureInfo.InvariantCulture).IsPolindrone())
                        break;

                    if (j == 49)
                        count++;
                }
            }

            return count;
        }

        #endregion

        #region Problem 56 - Powerful digit sum

        /*
A googol (10^100) is a massive number: one followed by one-hundred zeros; 100^100 is almost unimaginably large: 
 * one followed by two-hundred zeros. Despite their size, the sum of the digits in each number is only 1.

Considering natural numbers of the form, ab, where a, b  100, what is the maximum digital sum?
*/

        public static int Problem56()
        {
            var max = 0;
            for (var a = 1; a < 100; ++a)
                for (var b = 1; b < 100; ++b)
                {
                    var res = BigInteger.Pow(a, b);
                    max = Math.Max(max, res.ToString().DigitsValue());
                }

            return max;
        }

        #endregion

        #region Problem 57 - Square root convergents

        /*
It is possible to show that the square root of two can be expressed as an infinite continued fraction.

 2 = 1 + 1/(2 + 1/(2 + 1/(2 + ... ))) = 1.414213...

By expanding this for the first four iterations, we get:

1 + 1/2 = 3/2 = 1.5
1 + 1/(2 + 1/2) = 7/5 = 1.4
1 + 1/(2 + 1/(2 + 1/2)) = 17/12 = 1.41666...
1 + 1/(2 + 1/(2 + 1/(2 + 1/2))) = 41/29 = 1.41379...

The next three expansions are 99/70, 239/169, and 577/408, but the eighth expansion, 1393/985, is the first example where the number of digits in the numerator exceeds the number of digits in the denominator.

In the first one-thousand expansions, how many fractions contain a numerator with more digits than denominator?
*/

        public static int Problem57()
        {
            var count = 0;
            BigInteger nominator = 3;
            BigInteger denominator = 2;

            for (var i = 1; i < 1000; ++i)
            {
                nominator += denominator;

                var temp = nominator;
                nominator = denominator;
                denominator = temp;

                nominator += denominator;

                //Console.WriteLine(nominator + "/" + denominator);

                if (nominator.ToString().Length > denominator.ToString().Length)
                    count++;
            }

            return count;
        }

        #endregion

        #region Problem 58 - Spiral primes

        /*
Starting with 1 and spiralling anticlockwise in the following way, a square spiral with side length 7 is formed.

37 36 35 34 33 32 31
38 17 16 15 14 13 30
39 18  5  4  3 12 29
40 19  6  1  2 11 28
41 20  7  8  9 10 27
42 21 22 23 24 25 26
43 44 45 46 47 48 49

It is interesting to note that the odd squares lie along the bottom right diagonal, but what is more interesting is that
8 out of the 13 numbers lying along both diagonals are prime; that is, a ratio of 8/13  62%.

If one complete new layer is wrapped around the spiral above, a square spiral with side length 9 will be formed. 
If this process is continued, what is the side length of the square spiral for which the ratio of 
primes along both diagonals first falls below 10%?
*/

        public static int Problem58()
        {
            var totalCount = 1;
            var primes = 0;
            var height = 0;
            var last = 1;
            var index = 1;
            while (primes == 0 ||  primes / (double)totalCount > 0.1)
            {
                height = Height(index);
                var a = last + height - 1;
                var b = a + height - 1;
                var c = b + height - 1;
                var d = c + height - 1;
                last = d;

                totalCount += 4;
                if (a.IsPrime())
                    primes++;

                if (b.IsPrime())
                    primes++;

                if (c.IsPrime())
                    primes++;

                if (d.IsPrime())
                    primes++;

                index++;
            }

            return height;
        }

        #endregion
        
        #region Problem 59 - XOR decryption

        /*
Each character on a computer is assigned a unique code and the preferred standard is ASCII (American Standard Code for Information Interchange). 
For example, uppercase A = 65, asterisk (*) = 42, and lowercase k = 107.

A modern encryption method is to take a text file, convert the bytes to ASCII, then XOR each byte with a given value, taken from a secret key. 
The advantage with the XOR function is that using the same encryption key on the cipher text, restores the plain text; for example, 65 XOR 42 = 107,
then 107 XOR 42 = 65.

For unbreakable encryption, the key is the same length as the plain text message, and the key is made up of random bytes. 
The user would keep the encrypted message and the encryption key in different locations, and without both "halves", it 
is impossible to decrypt the message.

Unfortunately, this method is impractical for most users, so the modified method is to use a password as a key.
If the password is shorter than the message, which is likely, the key is repeated cyclically throughout the message. 
The balance for this method is using a sufficiently long password key for security, but short enough to be memorable.

Your task has been made easy, as the encryption key consists of three lower case characters. Using cipher1.txt (right click and 'Save Link/Target As...'), a file containing the encrypted ASCII codes, and the knowledge that the plain text must contain common English words, decrypt the message and find the sum of the ASCII values in the original text.
 */

        private static Dictionary<char, double> _freq = new Dictionary<char, double>
            {
                {'e', 12.702},
                {'t', 9.056},
                {'a', 8.167},
                {'o', 7.507},
                {'i', 6.966},
                {'n', 6.749},
                {'s', 6.327},
                /*{'h', 6.094},
                {'r', 5.987},
                {'d', 4.253},
                {'l', 4.025},
                {'c', 2.782},
                {'m', 2.406},
                {'w', 2.360},
                {'u', 2.758},
                {'f', 2.228},
                {'g', 2.015},
                {'y', 1.974},
                {'p', 1.929},
                {'b', 1.492},
                {'v', 0.978},
                {'k', 0.772},
                {'j', 0.153},
                {'x', 0.150},
                {'q', 0.095},
                {'z', 0.074}*/
            };

        public static int Problem59()
        {
            var line = File.ReadAllLines(@"Input\cipher.txt");
            var chars = line[0].Split(',').Select(Int32.Parse).Select(i => (char) i).ToArray();

            var dict = new Dictionary<string, double>();

            for (var i = 'a'; i <= 'z'; ++i)
                for (var j = 'a'; j <= 'z'; ++j)
                    for (var k = 'a'; k <= 'z'; ++k)
                    {
                        var text = Decrypt(chars, new[] {i, j, k});
                        var freq = CountFrequencies(text);
                        var diff = _freq.Sum(kvp => Math.Abs(kvp.Value - (freq.ContainsKey(kvp.Key) ? freq[kvp.Key] : 0)));
                        dict.Add(text, diff);
                    }

            var res = dict.OrderBy(kvp => kvp.Value).Select(kvp => kvp.Key).Take(1).First();

            return res.Select(ch => (int)ch).Sum();
        }

        private static Dictionary<char, double> CountFrequencies(string s)
        {
            var res = new Dictionary<char, double>();

            foreach (var ch in s.ToLower())
            {
                if (!res.ContainsKey(ch))
                    res[ch] = 0;

                res[ch]++;
            }

            foreach (var key in res.Keys.ToList())
                res[key] = res[key]/s.Length;

            return res;
        }

        private static string Decrypt(IEnumerable<char> chars, IList<char> key)
        {
            var current = 0;
            var sb = new StringBuilder();
            foreach (var ch in chars)
                sb.Append((char)(ch ^ key[current++ % 3]));

            return sb.ToString();
        }

        #endregion

        #region Problem 60 - Prime pair sets

        /*
The primes 3, 7, 109, and 673, are quite remarkable. By taking any two primes and concatenating them in any order the result will always be prime. For example, taking 7 and 109, both 7109 and 1097 are prime. The sum of these four primes, 792, represents the lowest sum for a set of four primes with this property.

Find the lowest sum for a set of five primes for which any two primes concatenate to produce another prime.
*/

        public static int Problem60()
        {
            var max = 10000;
            var primes = new List<int>(max.GetPrimes());

            for (var i = 0; i < primes.Count - 4; ++i)
            {
                var p1 = primes[i];
                for (var j = i + 1; j < primes.Count - 3; ++j)
                {
                    var p2 = primes[j];

                    if (!IsConcatenationPrime(p1, p2) || !IsConcatenationPrime(p2, p1))
                        continue;

                    for (var k = j + 1; k < primes.Count - 2; ++k)
                    {
                        var p3 = primes[k];

                        if (!IsConcatenationPrime(p1, p3) || !IsConcatenationPrime(p3, p1) ||
                            !IsConcatenationPrime(p2, p3) || !IsConcatenationPrime(p3, p2))
                            continue;

                        for (var l =  k + 1; l < primes.Count - 1; ++l)
                        {
                            var p4 = primes[l];

                            if (!IsConcatenationPrime(p1, p4) || !IsConcatenationPrime(p4, p1) ||
                                !IsConcatenationPrime(p2, p4) || !IsConcatenationPrime(p4, p2) ||
                                !IsConcatenationPrime(p3, p4) || !IsConcatenationPrime(p4, p3))
                                continue;

                            //return p1 + p2 + p3 + p4;

                            for (var m = l + 1; m < primes.Count; ++m)
                            {
                                var p5 = primes[m];

                                if (!IsConcatenationPrime(p1, p5) || !IsConcatenationPrime(p5, p1) ||
                                    !IsConcatenationPrime(p2, p5) || !IsConcatenationPrime(p5, p2) ||
                                    !IsConcatenationPrime(p3, p5) || !IsConcatenationPrime(p5, p3) ||
                                    !IsConcatenationPrime(p4, p5) || !IsConcatenationPrime(p5, p4))
                                    continue;

                                return p1 + p2 + p3 + p4 + p5;
                            }
                        }
                    }
                }
            }

            return -1;
        }

        public static bool IsConcatenationPrime(int p1, int p2)
        {
            return
                Int32.Parse(p1.ToString(CultureInfo.InvariantCulture) + p2.ToString(CultureInfo.InvariantCulture))
                     .IsPrime();
        }

        #endregion
    }
}

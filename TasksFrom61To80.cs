using System;
using System.Collections.Generic;
using System.Data;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Linq;

namespace ProjectEuler
{
    public partial class Solutions
    {
        #region Problem 61 - Cyclical figurate numbers

        /*
Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:

Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Square	 	P4,n=n^2	 	1, 4, 9, 16, 25, ...
Pentagonal	 	P5,n=n(3n-1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	P6,n=n(2n-1)	 	1, 6, 15, 28, 45, ...
Heptagonal	 	P7,n=n(5n-3)/2	 	1, 7, 18, 34, 55, ...
Octagonal	 	P8,n=n(3n-2)	 	1, 8, 21, 40, 65, ...
The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
This is the only set of 4-digit numbers with this property.
Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
*/

        public static long Problem61()
        {
            var sum = 0;

            var triangleDict = new Dictionary<long, int>();
            var squareDict = new Dictionary<long, int>();
            var pentagonalDict = new Dictionary<long, int>();
            var hexagonalDict = new Dictionary<long, int>();
            var heptagonalDict = new Dictionary<long, int>();
            var octagonalDict = new Dictionary<long, int>();

            for (var n = 45; n < 141; ++n)
                triangleDict.Add(n*(n + 1)/2, n);

            for (var n = 1; n < 1000; ++n)
            {
                squareDict.Add(n*n, n);
                pentagonalDict.Add(n*(3*n - 1)/2, n);
                hexagonalDict.Add(n*(2*n - 1), n);
                heptagonalDict.Add(n*(5*n - 3)/2, n);
                octagonalDict.Add(n*(3*n - 2), n);
            }

            foreach (var triangle in triangleDict.Keys)
            {
                foreach (var number in GetNext(triangle))
                {
                    var res = Check(triangle, number, new List<Dictionary<long, int>>
                        {
                            squareDict,
                            pentagonalDict,
                            hexagonalDict,
                            heptagonalDict,
                            octagonalDict
                        });

                    if (res != null)
                    {
                        Console.Write("{0} ({1}) ", triangle, triangleDict[triangle]);
                        Console.WriteLine();
                        return res.Value + triangle;
                    }
                }
            }

            return 0;
        }

        public static long? Check(long firstNumber, long number, List<Dictionary<long, int>> dicts)
        {
            for (var i = 0; i < dicts.Count; ++i)
                if (dicts[i].ContainsKey(number))
                {
                    if (dicts.Count == 1 && number%100 == firstNumber/100)
                    {
                        Console.Write("{0} ({1}), ", number, dicts[i][number]);
                        return number;
                    }

                    foreach (var nextNumber in GetNext(number))
                    {
                        var copy = new List<Dictionary<long, int>>(dicts);
                        copy.RemoveAt(i);
                        var res = Check(firstNumber, nextNumber, copy);
                        if (res != null)
                        {
                            Console.Write("{0} ({1}), ", number, dicts[i][number]);
                            return res + number;
                        }
                    }
                }

            return null;
        }

        public static IEnumerable<long> GetNext(long i)
        {
            i = (i%100)*100;

            if (i < 1000)
                yield break;

            for (var j = 10; j < 100; j++)
                yield return i + j;
        }

        #endregion

        #region Problem 62

        /*
The cube, 41063625 (345^3), can be permuted to produce two other cubes: 56623104 (384^3) and 66430125 (405^3). 
In fact, 41063625 is the smallest cube which has exactly three permutations of its digits which are also cube.

Find the smallest cube for which exactly five permutations of its digits are cube.
*/

        public static long Problem62()
        {
            var dict = new Dictionary<string, int>();
            var dict2 = new Dictionary<string, long>();
            checked
            {

                for (var i = 1; i < 10000; ++i)
                {
                    var cube = (long) Math.Pow(i, 3);
                    var key = String.Concat(cube.ToString(CultureInfo.InvariantCulture).OrderBy(ch => ch));
                    var counter = 0;
                    if (!dict.TryGetValue(key, out counter))
                    {
                        dict.Add(key, 1);
                        dict2.Add(key, cube);
                    }
                    else
                        dict[key] = counter + 1;

                    if (counter == 4)
                        return dict2[key];
                }
            }

            return -1;
        }

        public static long Problem62Old()
        {
            var tuples = new List<Tuple<long, string>>();
            checked
            {

                for (var i = 1; i < 10000; ++i)
                {
                    var cube = (long) Math.Pow(i, 3);
                    tuples.Add(new Tuple<long, string>(cube,
                                                       String.Concat(
                                                           cube.ToString(CultureInfo.InvariantCulture).OrderBy(ch => ch))));
                }
            }

            for (var i = 0; i < tuples.Count; ++i)
            {
                var cube = tuples[i];
                var counter = 0;

                for (var j = i + 1; j < tuples.Count; ++j)
                {
                    var cube2 = tuples[j];
                    if (cube.Item2.Length != cube2.Item2.Length)
                        continue;

                    if (IsPermutation(cube.Item2, cube2.Item2))
                        counter++;

                    if (counter > 4)
                        break;
                }

                if (counter == 4)
                    return cube.Item1;
            }

            return -1;
        }

        public static bool IsPermutation(string sort, string sort2)
        {
            for (var k = 0; k < sort.Length; ++k)
                if (sort[k] != sort2[k])
                    return false;

            return true;
        }

        #endregion

        #region Problem 63

        /*
The 5-digit number, 16807=7^5, is also a fifth power. Similarly, the 9-digit number, 134217728=8^9, is a ninth power.

How many n-digit positive integers exist which are also an nth power?
*/

        public static int Problem63()
        {
            var counter = 1;

            for (var n = 1; n < 100; n++)
            {
                var res = 0;
                var b = 2;
                while (res <= n)
                {
                    res = BigInteger.Pow(b, n).ToString().Length;

                    if (res == n)
                        counter++;

                    b++;
                }
            }

            return counter;
        }

        #endregion

        #region Problem 64 - Odd period square roots

        public static int Problem64()
        {
            var count = 0;

            for (var i = 2; i <= 10000; ++i)
            {
                var sqrt = Math.Sqrt(i);
                var floor = (int) Math.Floor(sqrt);

                if (sqrt != floor)
                {
                    var list = i.ContinuedFractionsExpansionOfSquareRoot();

                    if (list.Count%2 == 0)
                        count++;
                }
            }

            return count;
        }

        #endregion

        #region Problem 65 - Convergents of e

        public static int Problem65()
        {
            var list = new List<int>();
            list.Add(2);
            for (var i = 1; i < 34; ++i)
            {
                list.Add(1);
                list.Add(2*i);
                list.Add(1);
            }

            var res = list.ContinuedFractionsValue(99);

            return res.Item1.ToString().DigitsValue();
        }


        #endregion

        #region Problem 66 - Diophantine equation

        /// <summary>
        /// http://en.wikipedia.org/wiki/Pell%27s_equation
        /// See "Fundamental solution via continued fractions"
        /// </summary>
        /// <returns></returns>
        public static int Problem66()
        {
            BigInteger max = 0;
            var D = 0;
            for (var d = 1; d < 1000; ++d)
            {
                if (!d.IsSquare())
                {
                    var list = d.ContinuedFractionsExpansionOfSquareRoot();
                    var i = 0;
                    while (true)
                    {
                        var res = list.ContinuedFractionsValue(i);

                        if (res.Item1*res.Item1 - d*res.Item2*res.Item2 == 1)
                        {
                            if (res.Item1 > max)
                            {
                                max = res.Item1;
                                D = d;
                            }

                            break;
                        }
                        ++i;
                    }
                }
            }

            return D;
        }

        #endregion

        #region Problem 68 - 5-gon ring

        /*
Consider the following "magic" 3-gon ring, filled with the numbers 1 to 6, and each line adding to nine.

Working clockwise, and starting from the group of three with the numerically lowest external node (4,3,2 in this example), each solution can be described uniquely. For example, the above solution can be described by the set: 4,3,2; 6,2,1; 5,1,3.

It is possible to complete the ring with four different totals: 9, 10, 11, and 12. There are eight solutions in total.

Total	Solution Set
9	4,2,3; 5,3,1; 6,1,2
9	4,3,2; 6,2,1; 5,1,3
10	2,3,5; 4,5,1; 6,1,3
10	2,5,3; 6,3,1; 4,1,5
11	1,4,6; 3,6,2; 5,2,4
11	1,6,4; 5,4,2; 3,2,6
12	1,5,6; 2,6,4; 3,4,5
12	1,6,5; 3,5,4; 2,4,6
 
By concatenating each group it is possible to form 9-digit strings; the maximum string for a 3-gon ring is 432621513.

Using the numbers 1 to 10, and depending on arrangements, it is possible to form 16- and 17-digit strings. What is the maximum 16-digit string for a "magic" 5-gon ring?

*/

        public static string Problem68Old()
        {
            var perm = "0123456789".Permutations();

            var res = new Dictionary<string, string>();
            foreach (var p in perm)
            {

                if (p[0] != '0' && p[3] != '0' && p[5] != '0' && p[7] != '0' && p[9] != '0')
                    continue;

                if (Value(p[0]) > Value(p[3]) || Value(p[0]) > Value(p[5]) || Value(p[0]) > Value(p[7]) ||
                    Value(p[0]) > Value(p[9]))
                    continue;

                var a1 = Value(p[0]) + Value(p[1]) + Value(p[2]);
                var a2 = Value(p[3]) + Value(p[2]) + Value(p[4]);

                if (a1 == a2)
                {
                    var a3 = Value(p[5]) + Value(p[4]) + Value(p[6]);
                    if (a1 == a3)
                    {
                        var a4 = Value(p[7]) + Value(p[6]) + Value(p[8]);
                        if (a1 == a4)
                        {
                            var a5 = Value(p[9]) + Value(p[8]) + Value(p[1]);
                            if (a1 == a5)
                            {
                                res.Add(p,
                                        ToString(p[0]) + ToString(p[1]) + ToString(p[2]) +
                                        ToString(p[3]) + ToString(p[2]) + ToString(p[4]) +
                                        ToString(p[5]) + ToString(p[4]) + ToString(p[6]) +
                                        ToString(p[7]) + ToString(p[6]) + ToString(p[8]) +
                                        ToString(p[9]) + ToString(p[8]) + ToString(p[1]));
                            }
                        }
                    }
                }
            }

            var temp = res.Where(s => s.Value.Length == 16).OrderBy(s => s.Value).ToList();
            return temp[temp.Count - 1].Value;
        }

        public static int Value(char ch)
        {
            if (ch == '0')
                return 10;

            return ch - '0';
        }

        public static string ToString(char ch)
        {
            if (ch == '0')
                return "10";

            return ch.ToString(CultureInfo.InvariantCulture);
        }

        public static string Problem68()
        {
            var set = new[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
            var res = new List<string>();
            foreach (var p in set.Permutations())
            {
                if (p[1] == 10 || p[2] == 10 || p[4] == 10 || p[6] == 10 || p[8] == 10)
                    continue;

                if (p[0] > p[3] || p[0] > p[5] || p[0] > p[7] || p[0] > p[9])
                    continue;

                var a1 = p[0] + p[1] + p[2];
                var a2 = p[3] + p[2] + p[4];

                if (a1 == a2)
                {
                    var a3 = p[5] + p[4] + p[6];
                    if (a1 == a3)
                    {
                        var a4 = p[7] + p[6] + p[8];
                        if (a1 == a4)
                        {
                            var a5 = p[9] + p[8] + p[1];
                            if (a1 == a5)
                            {
                                res.Add(String.Empty + p[0] + p[1] + p[2] + p[3] + p[2] + p[4] + p[5] + p[4] + p[6] +
                                        p[7] + p[6] + p[8] + p[9] + p[8] + p[1]);
                            }
                        }
                    }
                }
            }

            return res.Where(s => s.Length == 16).OrderBy(s => s).Max();
        }

        #endregion

        #region Problem 69 - Totient Maximum

        /*
Euler's Totient function, φ(n) [sometimes called the phi function], is used to determine the number of numbers less than n which are relatively prime to n. For example, as 1, 2, 4, 5, 7, and 8, are all less than nine and relatively prime to nine, φ(9)=6.

n	Relatively Prime	φ(n)	n/φ(n)
2	1	1	2
3	1,2	2	1.5
4	1,3	2	2
5	1,2,3,4	4	1.25
6	1,5	2	3
7	1,2,3,4,5,6	6	1.1666...
8	1,3,5,7	4	2
9	1,2,4,5,7,8	6	1.5
10	1,3,7,9	4	2.5
It can be seen that n=6 produces a maximum n/φ(n) for n ≤ 10.

Find the value of n ≤ 1,000,000 for which n/φ(n) is a maximum.
*/

        public static int Problem69()
        {
            var max = 0.0;
            var res = -1;
            var dict = new Dictionary<long, long>
                {
                    {2, 1}
                };

            for (var n = 3; n < 750; ++n)
            {
                long count;

                if (!dict.TryGetValue(n, out count))
                {
                    var relPrimes = n.EulersTotient();

                    count += relPrimes.Count;

                    dict[n] = count;
                    foreach (var relPrime in relPrimes)
                    {
                        var n1 = n*relPrime;
                        if (relPrime != 1 && n1 < 1000000)
                        {
                            var count1 = count*dict[relPrime];
                            dict[n1] = count1;

                            if (n1/(double) count1 > max)
                            {
                                max = n1/(double) count1;
                                res = n1;
                            }
                        }
                    }
                }

                if (n/(double) count > max)
                {
                    max = n/(double) count;
                    res = n;
                }
            }

            return res;
        }

        #endregion

        #region Problem 70 - Totient Permutation

        /*
Euler's Totient function, φ(n) [sometimes called the phi function], is used to determine 
the number of positive numbers less than or equal to n which are relatively prime to n. 
For example, as 1, 2, 4, 5, 7, and 8, are all less than nine and relatively prime to nine, φ(9)=6.
The number 1 is considered to be relatively prime to every positive number, so φ(1)=1.

Interestingly, φ(87109)=79180, and it can be seen that 87109 is a permutation of 79180.

Find the value of n, 1 < n < 10^7, for which φ(n) is a permutation of n and the ratio n/φ(n) produces a minimum.
*/

        public static int Problem70()
        {
            var sqrt = (int) Math.Sqrt(10000000);
            var primes = (sqrt + 500).GetPrimes().ToList();

            var res = 0;
            var max = 0.0;
            for (var i = primes.Count - 1; i >= 0; i--)
                for (var j = primes.Count - 1; j >= 0; j--)
                {
                    var p1 = primes[i];
                    var p2 = primes[j];

                    if (p1*p2 < 10000000)
                    {
                        var phi = (p1 - 1)*(p2 - 1);
                        var number = p1*p2;
                        var ratio = phi/(double) number;
                        if (ratio > max)
                        {
                            if (phi.IsPermutation(number))
                            {
                                res = number;
                                max = ratio;
                            }
                        }
                    }
                }

            return res;
        }

        #endregion

        #region Problem 71 - Ordered fractions

        /*
Consider the fraction, n/d, where n and d are positive integers. If n<d and HCF(n,d)=1, it is called a reduced proper fraction.

If we list the set of reduced proper fractions for d ≤ 8 in ascending order of size, we get:

1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8

It can be seen that 2/5 is the fraction immediately to the left of 3/7.

By listing the set of reduced proper fractions for d ≤ 1,000,000 in ascending order of size, find the numerator of the fraction immediately to the left of 3/7.
*/

        public static int Problem71()
        {
            const decimal number = 3/7m;
            const int upperbound = (int) (number*1000000);
            const int lowerboud = upperbound - 1000;

            var estimation = 0m;
            var nominator = 0;
            var denominator = 0;

            for (var i = upperbound; i > lowerboud; --i)
                for (var j = 1000000; j > 0; --j)
                {
                    var e = i/(decimal) j;

                    if (e < number)
                    {
                        if (i.GreatestCommonDivisor(j) == 1)
                        {
                            if (e < estimation)
                                continue;

                            estimation = e;
                            nominator = i;
                            denominator = j;
                        }
                    }
                    else
                    {
                        break;
                    }
                }


            return nominator;
        }

        #endregion

        #region Problem 72 - Counting fractions

/*
Consider the fraction, n/d, where n and d are positive integers. If n<d and HCF(n,d)=1, it is called a reduced proper fraction.

If we list the set of reduced proper fractions for d ≤ 8 in ascending order of size, we get:

1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8

It can be seen that there are 21 elements in this set.

How many elements would be contained in the set of reduced proper fractions for d ≤ 1,000,000?
*/

        //303963552391

        public static long Problem72()
        {
            var max = 1000000;
            var c = 0L;

            for (var i = 2; i <= max; ++i)
            {
                var fact = i.Factorization().Distinct().ToList();

                var n = 1L;
                var d = 1L;
                foreach (var number in fact)
                {
                    n *= number - 1;
                    d *= number;
                }

                c += i*n/d;
            }

            return c;
        }

        #endregion

        #region Problem 73 - Counting fractions in range

/*
Consider the fraction, n/d, where n and d are positive integers. If n<d and HCF(n,d)=1, it is called a reduced proper fraction.

If we list the set of reduced proper fractions for d ≤ 8 in ascending order of size, we get:

1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8

It can be seen that there are 3 fractions between 1/3 and 1/2.

How many fractions lie between 1/3 and 1/2 in the sorted set of reduced proper fractions for d ≤ 12,000?
*/

        public static long Problem73()
        {
            var max = 12000;
            var c = 0L;

            for (var d = 2; d <= max; ++d)
            {
                int lower = (int) Math.Ceiling(d/3.0);
                int upper = (int) Math.Floor(d/2.0);

                for (var n = lower; n <= upper; ++n)
                {
                    if (n.GreatestCommonDivisor(d) == 1)
                        c++;
                }
            }

            return c - 2;
        }

        #endregion

        #region Problem 74 - Digit factorial chains

        /*
 The number 145 is well known for the property that the sum of the factorial of its digits is equal to 145:

1! + 4! + 5! = 1 + 24 + 120 = 145

Perhaps less well known is 169, in that it produces the longest chain of numbers that link back to 169; it turns out that there are only three such loops that exist:

169 → 363601 → 1454 → 169
871 → 45361 → 871
872 → 45362 → 872

It is not difficult to prove that EVERY starting number will eventually get stuck in a loop. For example,

69 → 363600 → 1454 → 169 → 363601 (→ 1454)
78 → 45360 → 871 → 45361 (→ 871)
540 → 145 (→ 145)

Starting with 69 produces a chain of five non-repeating terms, but the longest non-repeating chain with a starting number below one million is sixty terms.

How many chains, with a starting number below one million, contain exactly sixty non-repeating terms?
 */

        public static int Problem74()
        {
            var range = Enumerable.Range(1, 1000000).AsParallel();
            var count = range.Count(i => Length(i) == 60);

            return count;
        }

        public static int Length(int i)
        {
            var hashset = new HashSet<int>();
            hashset.Add(i);
            while (true)
            {
                i = i.ToDigits().Sum(d => d.Factorial());

                if (hashset.Contains(i))
                    break;

                hashset.Add(i);
            }

            return hashset.Count;
        }

        #endregion

        #region Problem 75 - Singular integer right triangles

        /*
It turns out that 12 cm is the smallest length of wire that can be bent to form an integer sided right angle
triangle in exactly one way, but there are many more examples.

12 cm: (3,4,5)
24 cm: (6,8,10)
30 cm: (5,12,13)
36 cm: (9,12,15)
40 cm: (8,15,17)
48 cm: (12,16,20)

In contrast, some lengths of wire, like 20 cm, cannot be bent to form an integer sided right
angle triangle, and other lengths allow more than one solution to be found; for example, using 120 cm it
is possible to form exactly three different integer sided right angle triangles.

120 cm: (30,40,50), (20,48,52), (24,45,51)

Given that L is the length of the wire, for how many values of L ≤ 1,500,000 can exactly one integer
sided right angle triangle be formed?
*/

        public static int Problem75()
        {
            //a = m^2 - n^2
            //b = 2mn 
            //c = m^2 + n^2 
            // m i n całkowote
            // m > n
            // L = m^2 - n^2 + 2mn + m^2 + n^2 = 2m^2 + 2mn = 2m(m + n) < 1,500,000
            // Rozwiązanie równania i stąd limit na m
            // http://www.wolframalpha.com/input/?i=2m%28m+%2B+n%29+%3C+1500000%2C+m+%3E+0%2C+n+%3E+0%2C+m+%3E+n
            var maxL = 1500000;
            var dict = new Dictionary<int, int>();
            for (var m = 1; m < 866; ++m)
            {
                for (var n = 1; n < m; ++n)
                {
                    if ((m - n)%2 == 1 && m.GreatestCommonDivisor(n) == 1)
                    {
                        //https://en.wikipedia.org/wiki/Pythagorean_triple
                        var a = m*m - n*n;
                        var b = 2*m*n;
                        var c = m*m + n*n;
                        var l = a + b + c;
                        var newL = l;
                        while (newL < maxL)
                        {
                            if (!dict.ContainsKey(newL))
                                dict[newL] = 1;
                            else
                                dict[newL] += 1;

                            newL += l;
                        }
                    }
                } 
            }

            var count = dict.Count(kvp => kvp.Value == 1);
            return count;
        }

        #endregion

        #region Problem 76 - Counting summations

        /*
It is possible to write five as a sum in exactly six different ways:

4 + 1
3 + 2
3 + 1 + 1
2 + 2 + 1
2 + 1 + 1 + 1
1 + 1 + 1 + 1 + 1

How many different ways can one hundred be written as a sum of at least two positive integers?
*/

        //See http://en.wikipedia.org/wiki/Partition_(number_theory)

        #endregion

        #region Problem 77 - Prime summations

/*
It is possible to write ten as the sum of primes in exactly five different ways:

7 + 3
5 + 5
5 + 3 + 2
3 + 3 + 2 + 2
2 + 2 + 2 + 2 + 2

What is the first value which can be written as the sum of primes in over five thousand different ways?
*/

        public static int Problem77()
        {
            var primes = 500.GetPrimes().ToList();

            var ways = new long[500];
            ways[0] = 1;

            foreach (var p in primes)
            {
                for (var i = 0; i + p < ways.Length; ++i)
                    ways[i + p] += ways[i];
            }

            var res = ways.Count(i => i < 5000);

            return res;
        }

        #endregion

        #region Problem 78 - Coin partitions

/*
Let p(n) represent the number of different ways in which n coins can be separated into piles. For example, five coins can separated into piles in exactly seven different ways, so p(5)=7.

OOOOO
OOOO   O
OOO   OO
OOO   O   O
OO   OO   O
OO   O   O   O
O   O   O   O   O
Find the least value of n for which p(n) is divisible by one million.
*/

        /// <summary>
        /// See section Relation with partitions in https://en.wikipedia.org/wiki/Pentagonal_number_theorem
        /// See formula number 11 in  http://mathworld.wolfram.com/PartitionFunctionP.html
        /// </summary>
        /// <returns></returns>
        public static int Problem78()
        {
            var pentagonals = new List<int>();
            for (var n = 1; n < 10000; ++n)
            {
                pentagonals.Add(n*(3*n - 1)/2); //Pentagonal for positive K
                pentagonals.Add(n * (3 * n + 1) / 2); //Pentagonal for negative K
            }

            var partitions = new List<int> {1};

            for (var n = 1;; n++)
            {
                var count = 0;
                for (var k = 0;; ++k)
                {
                    var index = n - pentagonals[k];
                    if (index < 0)
                        break;

                    var sign = (k/2)%2 == 0 ? 1 : -1;

                    count += sign*partitions[index];
                }

                //In order to calcualte last 6 digits of the very big numbers it is enough to 
                //store the last six digits of previous numebrs
                partitions.Add(count%1000000);

                if (count%1000000 == 0)
                    return n;
            }
        }

        #endregion

        #region Problem 79 - Pascode derivation

        /*
         A common security method used for online banking is to ask the user for three random characters from a passcode. For example, if the passcode was 531278, they may ask for the 2nd, 3rd, and 5th characters; the expected reply would be: 317.

The text file, keylog.txt, contains fifty successful login attempts.

Given that the three characters are always asked for in order, analyse the file so as to determine the shortest possible secret passcode of unknown length.
         */

        public static string Problem79()
        {
            var keylogs = File.ReadAllLines(@"Input\keylog.txt");
            keylogs = keylogs.Distinct().ToArray();
            keylogs = keylogs.OrderBy(k => k).ToArray();

            var candidates = new List<string>();
            foreach (var keylog in keylogs)
            {
                var ch1 = keylog[0];
                var ch2 = keylog[1];
                var ch3 = keylog[2];

                if (candidates.Count == 0)
                    candidates.Add(keylog);
                else
                {
                    candidates = Candidates(candidates, 'a', ch1);
                    candidates = Candidates(candidates, ch1, ch2);
                    candidates = Candidates(candidates, ch2, ch3);
                }
            }

            return candidates.OrderBy(c => c.Length).First();
        }

        private static List<string> Candidates(List<string> candidates, char prev, char next)
        {
            var newCandidates= candidates.Where(c => c.LastIndexOf(next) > c.IndexOf(prev)).ToList();

            if (newCandidates.Count == 0)
                newCandidates = NewCandidates(candidates, prev, next);

            return newCandidates;
        }

        private static List<string> NewCandidates(IEnumerable<string> candidates, char prev, char next)
        {
            var newCandidates = new List<string>();

            foreach (var c in candidates)
            {
                var j = c.IndexOf(prev);
                for (var i = j + 1; i <= c.Length; ++i)
                    newCandidates.Add(c.Substring(0, i) + next + c.Substring(i));
            }

            return newCandidates;
        }

        #endregion

        #region Problem 80 - Square root digital expansion
        /*
It is well known that if the square root of a natural number is not an integer, then it is irrational. 
The decimal expansion of such square roots is infinite without any repeating pattern at all.

The square root of two is 1.41421356237309504880..., and the digital sum of the first one hundred decimal digits is 475.

For the first one hundred natural numbers, find the total of the digital sums of the first one hundred decimal 
digits for all the irrational square roots.
*/
        public static int Problem80()
        {
            var sum = 0;
            for (var i = 1; i < 101; ++i)
            {
                if (Math.Floor(Math.Sqrt(i)) != Math.Sqrt(i))
                {
                    var ex = i.ContinuedFractionsExpansionOfSquareRoot();
                    var val = ex.ContinuedFractionsValue(200);
                    var n = val.Item1;
                    var d = val.Item2;

                    var list = new List<int>();


                    while (list.Count < 100)
                    {
                        var res = n / d;
                        list.Add(Int32.Parse(res.ToString()));

                        n -= res * d;
                        n *= 10;

                    }

                    var s = list.Aggregate((a, b) => a + b);
                    var str = list.Aggregate("", (a, b) => a + b.ToString());

                    sum += s;
                }
            }

            return sum;
        }

        private static BigInteger Squareroot(int n, int digits)
        {
            BigInteger limit = BigInteger.Pow(10, digits + 1);
            BigInteger a = 5 * n;
            BigInteger b = 5;

            while (b < limit)
            {
                if (a >= b)
                {
                    a -= b;
                    b += 10;
                }
                else
                {
                    a *= 100;
                    b = (b / 10) * 100 + 5;
                }
            }

            return b / 100;
        }

        private static int DigitSum(BigInteger number)
        {
            char[] k = number.ToString().ToCharArray();
            int ds = 0;

            for (int i = 0; i < k.Length; i++)
            {
                ds += k[i] - '0';
            }

            return ds;
        }

        #endregion
    }
}
